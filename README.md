### Порівняння розвязання задачі отримання кількості монет для заданого значення двома підходами. Перший - жадібний алгоритм, другий - динамічне програмування.

| Value | find_coins_greedy | find_min_coins (sec) |
|------:|-------------------:|---------------:|
| 16  | 0.000007375 | 0.000032500 |
| 127 | 0.000004917 | 0.000220458 |
| 264 | 0.000007250 | 0.000488709 |
| 339 | 0.000007542 | 0.000631625 |
| 473 | 0.000009042 | 0.000904459 |
| 591 | 0.000009625 | 0.001195708 |

#### Жадібний алгоритм:
Результати мають характер збільшення, але розмірність залишається тією ж. Що і відповідає часовій складності O(n)
#### Динамічне програмування:
Із збільшенням значення, яке потрібно розібрати на монети, час виконання збільшується. Результати показують, що ці зміни мають більш стрімкий характер, що відповідає часовій складності O(nW)

#### Висновок:
Коли головним критерієм роботи програми є час - краще підходить жадібний алгоритм, якщо ж потрібно саме оптимальне вирішення задачі - кращим рішенням буде використання Динамічного програмування.
